# Задание

Задание проверяет понимание технологий и умение это понимание применять на практике на базе вашего существующего опыта.


Репозиторий содержит некоторе решение некоторой задачи. И задача и решене здесь приведены
только для наглядности. Ответ на каждый вопрос принимается исключительно про ваш реальный опыт над реальным проектом.
Мы ожидаем развернутых ответов.

Решением задания будет написание ответов на вопросы ниже. Ответ можно отправить в свободной форме.

## Аутентификация

Для аутентификации в этом репозитории используется jwt токен. Технология известная, зарекомендовавшая себя. 
Давайте в ней усомнимся. Как минимум - в целесообразности гонять в каждом http запросе такой большой кусок данных.
Расскажите о проектах с вашим участием, где использовалась другая техника авторизации. 
Если в таких проектах вы бы могли выбирать - выбрали бы вы аутентификацию через jwt? Если да, то почему?
В каком проекте, в котором вы участвовали, вы бы наоборот, вместо jwt выбрали что-то другое и почему?

---

### Мой ответ:

В РЖД для внутренних систем мы использовали сессии через Active Directory. Логично — все сотрудники уже там, logout мгновенный, ничего изобретать не надо.

В Полихроме ситуация другая: несколько сервисов (рендеринг, платежи, уведомления), и JWT тут прямо зашёл. Каждый сервис сам проверяет токен, не нужно дёргать центральный auth-сервис на каждый запрос.

**Когда бы выбрал JWT:**
- Несколько сервисов — не хочется создавать узкое место в виде auth-сервиса
- Нужно масштабироваться — с сессиями пришлось бы синхронизировать их между серверами

**Когда бы выбрал сессии:**
- Корпоративка с Active Directory — зачем усложнять
- Нужен мгновенный logout — JWT просто так не отзовёшь, придётся городить чёрные списки

В своём pet-проекте сейчас JWT, но честно говоря, для продакшена скорее взял бы сессии с Redis — проще контролировать, кто залогинен, и можно сразу блокировать подозрительную активность.

---

## Идентификация

В этом репозтории в некоторых таблицах для идентификации записи используется uuid. Эта техника удобна по нескольким параметрам.
Сложно представить, чтобы использование uuid во всех таблицах - как стандарта - создало бы где нибудь проблему.
Но может быть в вашей практике встречались случаи, где uuid как идентификатор стал проблемой или мог бы стать проблемой?
Опишите где и почему.

---

### Мой ответ:

Да, были случаи, когда UUID мешал:

**Большие таблицы в РЖД**

Мониторинг поездов — миллионы записей. Случайные UUID плохо ложатся в индекс базы данных, вставки начинают тормозить. Сделали просто: внутри базы обычные числовые ID, а UUID только для внешнего API — чтобы нельзя было перебором угадать чужие записи.

**3D-сцены в Полихроме**

Каждый объект в Three.js имеет UUID. Сцена с 50+ моделями — и JSON раздувается из-за длинных строк. Внутри сцены перешли на короткие числовые ID, UUID оставили только для сохранения через API.

**Отладка**

Когда в 2 часа ночи разбираешь инцидент, искать в логах `8c3eed83-8a8a-41a0-8f91-9ad501e8f8a1` — то ещё удовольствие. С `12345` жить проще.

**Когда UUID всё-таки нужен:**
- Несколько серверов генерируют ID независимо
- Публичный API — чтобы нельзя было угадать ID соседней записи

---

## Организация кода

В этом репозитории, серверный код сделан на базе NestJS. 
DI, services, controllers, middleware, decorators - в этом, как и во многих других подходах есть плюсы и выгоды.
Расскажите с примерами из опыта о реальной пользе того или иного механизма организации кода лично для вас или
для вашей команды, а может быть - для компании. Если есть какой-то механим, который также - для вас, команды 
или компании наоборот - создавал сложности - тоже расскажите.

---

### Мой ответ:

**Что помогало**

В Полихроме работал с NestJS, и несколько вещей реально упростили жизнь:

*Внедрение зависимостей* — сервис рендеринга мог работать и с локальным Docker, и с облачным GPU. Переключаюсь одной строкой конфига, код не трогаю. В тестах вообще красота — подменяешь платёжку на заглушку, и тесты летают.

*Модули* — разбил проект на логические части: рендеринг, авторизация, платежи. Новый человек открывает папку и сразу видит всё, что к ней относится.

*Разделение логики и API* — сервис рендеринга использовался из трёх мест: REST API, WebSocket для статуса в реальном времени, Telegram-бот. Один код — три способа достучаться.

**Что мешало**

*Много шаблонного кода* — в РЖД для простых справочников NestJS был избыточен. Таблица из 5 полей, а надо создать модуль, контроллер, сервис, типы... Для таких случаев брал обычный Express.

*Циклические зависимости* — модуль рендеринга должен уведомлять модуль нотификаций, а тот — знать о статусе рендера. Замкнутый круг. Решил, но потратил полдня на отладку.

---

## Реактивность

В этом репозитории, для интерфейса используется React. Его название связано с реактивным подходом к отрисовке
интерфейса - мы меняем состояние, а интерфейс перерисовывается в соответствии с этим. 
Сам посыл подкупает - разработчик заботится о состоянии, остальное за него делает фреймворк. 
Такой подход, конечно, помимо React реализуют и многие другие фреймворки. 
Были ли ситуации в вашем опыте, когда реактивность была не плюсом, а помехой? Если да, расскажите на примере.
Если был опыт построения рендера интерфеса на другом принципе, раскажите на каком и какие были резльтаты?
Расскажите на конкретных примерах, что вам доставляет неудобства в том, как реактивность реализована
непосредственно во фреймворке React?

---

### Мой ответ:

В целом реактивность — это удобно. Описываешь интерфейс как функцию от состояния, и не думаешь о ручном обновлении. Но пару раз приходилось искать обходные пути.

**Когда реактивность мешала**

*3D-конфигуратор в Полихроме*

React управляет обычными элементами страницы, Three.js — 3D-сценой. Первая версия тормозила: крутишь модель — React перерисовывает весь компонент. Решение простое: 3D-сцена живёт отдельно от React, а React отвечает только за кнопки и панели вокруг. Каждый делает своё дело.

*Дашборды в РЖД*

Таблица на 500+ строк, обновляется каждые 2 секунды. В лоб не работало, но React даёт инструменты: виртуализация (рисуем только видимые строки), мемоизация (не перерисовываем то, что не изменилось). После оптимизации всё летало.

**Опыт с Vue.js**

Часть проектов в РЖД делал на Vue. Для простых случаев он удобнее — меньше писанины. Но в сложных сценариях мне не хватало явности. В React видишь `setState` — точно знаешь, что будет перерисовка. В Vue это менее очевидно.

**К чему пришлось привыкнуть**

*useEffect* — поначалу путался, какие зависимости указывать. Сейчас это на автомате, плюс линтер подсказывает.

*Замыкания* — классическая ловушка: обработчик события "запоминает" старое значение переменной. Решается, но надо знать про эту особенность.

В итоге React — мой основной инструмент. Предсказуемый, с огромной экосистемой. Нюансы есть, но они решаемы.

---
